{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///Users/mohammadsaalim/projects/node_modules/%40peculiar/webcrypto/build/webcrypto.es.js"],"sourcesContent":["/*!\n Copyright (c) Peculiar Ventures, LLC\n*/\n\nimport * as core from 'webcrypto-core';\nimport { BufferSourceConverter as BufferSourceConverter$1 } from 'webcrypto-core';\nexport { CryptoKey } from 'webcrypto-core';\nimport { Buffer as Buffer$1 } from 'buffer';\nimport crypto from 'crypto';\nimport * as process from 'process';\nimport { __decorate } from 'tslib';\nimport { JsonProp, JsonPropTypes, JsonSerializer, JsonParser } from '@peculiar/json-schema';\nimport { Convert, BufferSourceConverter } from 'pvtsutils';\nimport { AsnParser, AsnSerializer, AsnConvert } from '@peculiar/asn1-schema';\n\nconst JsonBase64UrlConverter = {\n    fromJSON: (value) => Buffer$1.from(Convert.FromBase64Url(value)),\n    toJSON: (value) => Convert.ToBase64Url(value),\n};\n\nclass CryptoKey extends core.CryptoKey {\n    constructor() {\n        super(...arguments);\n        this.data = Buffer$1.alloc(0);\n        this.algorithm = { name: \"\" };\n        this.extractable = false;\n        this.type = \"secret\";\n        this.usages = [];\n        this.kty = \"oct\";\n        this.alg = \"\";\n    }\n}\n__decorate([\n    JsonProp({ name: \"ext\", type: JsonPropTypes.Boolean, optional: true })\n], CryptoKey.prototype, \"extractable\", void 0);\n__decorate([\n    JsonProp({ name: \"key_ops\", type: JsonPropTypes.String, repeated: true, optional: true })\n], CryptoKey.prototype, \"usages\", void 0);\n__decorate([\n    JsonProp({ type: JsonPropTypes.String })\n], CryptoKey.prototype, \"kty\", void 0);\n__decorate([\n    JsonProp({ type: JsonPropTypes.String, optional: true })\n], CryptoKey.prototype, \"alg\", void 0);\n\nclass SymmetricKey extends CryptoKey {\n    constructor() {\n        super(...arguments);\n        this.kty = \"oct\";\n        this.type = \"secret\";\n    }\n}\n\nclass AsymmetricKey extends CryptoKey {\n}\n\nclass AesCryptoKey extends SymmetricKey {\n    get alg() {\n        switch (this.algorithm.name.toUpperCase()) {\n            case \"AES-CBC\":\n                return `A${this.algorithm.length}CBC`;\n            case \"AES-CTR\":\n                return `A${this.algorithm.length}CTR`;\n            case \"AES-GCM\":\n                return `A${this.algorithm.length}GCM`;\n            case \"AES-KW\":\n                return `A${this.algorithm.length}KW`;\n            case \"AES-CMAC\":\n                return `A${this.algorithm.length}CMAC`;\n            case \"AES-ECB\":\n                return `A${this.algorithm.length}ECB`;\n            default:\n                throw new core.AlgorithmError(\"Unsupported algorithm name\");\n        }\n    }\n    set alg(value) {\n    }\n}\n__decorate([\n    JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\n], AesCryptoKey.prototype, \"data\", void 0);\n\nclass AesCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const key = new AesCryptoKey();\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto.randomBytes(algorithm.length >> 3);\n        return key;\n    }\n    static async exportKey(format, key) {\n        if (!(key instanceof AesCryptoKey)) {\n            throw new Error(\"key: Is not AesCryptoKey\");\n        }\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                return JsonSerializer.toJSON(key);\n            case \"raw\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new core.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                key = JsonParser.fromJSON(keyData, { targetSchema: AesCryptoKey });\n                break;\n            case \"raw\":\n                key = new AesCryptoKey();\n                key.data = Buffer$1.from(keyData);\n                break;\n            default:\n                throw new core.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = algorithm;\n        key.algorithm.length = key.data.length << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        switch (key.algorithm.length) {\n            case 128:\n            case 192:\n            case 256:\n                break;\n            default:\n                throw new core.OperationError(\"keyData: Is wrong key length\");\n        }\n        return key;\n    }\n    static async encrypt(algorithm, key, data) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"AES-CBC\":\n                return this.encryptAesCBC(algorithm, key, Buffer$1.from(data));\n            case \"AES-CTR\":\n                return this.encryptAesCTR(algorithm, key, Buffer$1.from(data));\n            case \"AES-GCM\":\n                return this.encryptAesGCM(algorithm, key, Buffer$1.from(data));\n            case \"AES-KW\":\n                return this.encryptAesKW(algorithm, key, Buffer$1.from(data));\n            case \"AES-ECB\":\n                return this.encryptAesECB(algorithm, key, Buffer$1.from(data));\n            default:\n                throw new core.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        if (!(key instanceof AesCryptoKey)) {\n            throw new Error(\"key: Is not AesCryptoKey\");\n        }\n        switch (algorithm.name.toUpperCase()) {\n            case \"AES-CBC\":\n                return this.decryptAesCBC(algorithm, key, Buffer$1.from(data));\n            case \"AES-CTR\":\n                return this.decryptAesCTR(algorithm, key, Buffer$1.from(data));\n            case \"AES-GCM\":\n                return this.decryptAesGCM(algorithm, key, Buffer$1.from(data));\n            case \"AES-KW\":\n                return this.decryptAesKW(algorithm, key, Buffer$1.from(data));\n            case \"AES-ECB\":\n                return this.decryptAesECB(algorithm, key, Buffer$1.from(data));\n            default:\n                throw new core.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encryptAesCBC(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = Buffer$1.concat([enc, cipher.final()]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesCBC(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = Buffer$1.concat([dec, decipher.final()]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesCTR(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ctr`, key.data, Buffer$1.from(algorithm.counter));\n        let enc = cipher.update(data);\n        enc = Buffer$1.concat([enc, cipher.final()]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesCTR(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ctr`, key.data, new Uint8Array(algorithm.counter));\n        let dec = decipher.update(data);\n        dec = Buffer$1.concat([dec, decipher.final()]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesGCM(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-gcm`, key.data, Buffer$1.from(algorithm.iv), {\n            authTagLength: (algorithm.tagLength || 128) >> 3,\n        });\n        if (algorithm.additionalData) {\n            cipher.setAAD(Buffer$1.from(algorithm.additionalData));\n        }\n        let enc = cipher.update(data);\n        enc = Buffer$1.concat([enc, cipher.final(), cipher.getAuthTag()]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesGCM(algorithm, key, data) {\n        const tagLength = (algorithm.tagLength || 128) >> 3;\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-gcm`, key.data, new Uint8Array(algorithm.iv), {\n            authTagLength: tagLength,\n        });\n        const enc = data.slice(0, data.length - tagLength);\n        const tag = data.slice(data.length - tagLength);\n        if (algorithm.additionalData) {\n            decipher.setAAD(Buffer$1.from(algorithm.additionalData));\n        }\n        decipher.setAuthTag(tag);\n        let dec = decipher.update(enc);\n        dec = Buffer$1.concat([dec, decipher.final()]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesKW(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\n        let enc = cipher.update(data);\n        enc = Buffer$1.concat([enc, cipher.final()]);\n        return new Uint8Array(enc).buffer;\n    }\n    static async decryptAesKW(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`id-aes${key.algorithm.length}-wrap`, key.data, this.AES_KW_IV);\n        let dec = decipher.update(data);\n        dec = Buffer$1.concat([dec, decipher.final()]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptAesECB(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\n        let enc = cipher.update(data);\n        enc = Buffer$1.concat([enc, cipher.final()]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptAesECB(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`aes-${key.algorithm.length}-ecb`, key.data, new Uint8Array(0));\n        let dec = decipher.update(data);\n        dec = Buffer$1.concat([dec, decipher.final()]);\n        return new Uint8Array(dec).buffer;\n    }\n}\nAesCrypto.AES_KW_IV = Buffer$1.from(\"A6A6A6A6A6A6A6A6\", \"hex\");\n\nconst keyStorage = new WeakMap();\nfunction getCryptoKey(key) {\n    const res = keyStorage.get(key);\n    if (!res) {\n        throw new core.OperationError(\"Cannot get CryptoKey from secure storage\");\n    }\n    return res;\n}\nfunction setCryptoKey(value) {\n    const key = core.CryptoKey.create(value.algorithm, value.type, value.extractable, value.usages);\n    Object.freeze(key);\n    keyStorage.set(key, value);\n    return key;\n}\n\nclass AesCbcProvider extends core.AesCbcProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length,\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\n\nconst zero = Buffer$1.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]);\nconst rb = Buffer$1.from([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 135]);\nconst blockSize = 16;\nfunction bitShiftLeft(buffer) {\n    const shifted = Buffer$1.alloc(buffer.length);\n    const last = buffer.length - 1;\n    for (let index = 0; index < last; index++) {\n        shifted[index] = buffer[index] << 1;\n        if (buffer[index + 1] & 0x80) {\n            shifted[index] += 0x01;\n        }\n    }\n    shifted[last] = buffer[last] << 1;\n    return shifted;\n}\nfunction xor(a, b) {\n    const length = Math.min(a.length, b.length);\n    const output = Buffer$1.alloc(length);\n    for (let index = 0; index < length; index++) {\n        output[index] = a[index] ^ b[index];\n    }\n    return output;\n}\nfunction aes(key, message) {\n    const cipher = crypto.createCipheriv(`aes${key.length << 3}`, key, zero);\n    const result = cipher.update(message);\n    cipher.final();\n    return result;\n}\nfunction getMessageBlock(message, blockIndex) {\n    const block = Buffer$1.alloc(blockSize);\n    const start = blockIndex * blockSize;\n    const end = start + blockSize;\n    message.copy(block, 0, start, end);\n    return block;\n}\nfunction getPaddedMessageBlock(message, blockIndex) {\n    const block = Buffer$1.alloc(blockSize);\n    const start = blockIndex * blockSize;\n    const end = message.length;\n    block.fill(0);\n    message.copy(block, 0, start, end);\n    block[end - start] = 0x80;\n    return block;\n}\nfunction generateSubkeys(key) {\n    const l = aes(key, zero);\n    let subkey1 = bitShiftLeft(l);\n    if (l[0] & 0x80) {\n        subkey1 = xor(subkey1, rb);\n    }\n    let subkey2 = bitShiftLeft(subkey1);\n    if (subkey1[0] & 0x80) {\n        subkey2 = xor(subkey2, rb);\n    }\n    return { subkey1, subkey2 };\n}\nfunction aesCmac(key, message) {\n    const subkeys = generateSubkeys(key);\n    let blockCount = Math.ceil(message.length / blockSize);\n    let lastBlockCompleteFlag;\n    let lastBlock;\n    if (blockCount === 0) {\n        blockCount = 1;\n        lastBlockCompleteFlag = false;\n    }\n    else {\n        lastBlockCompleteFlag = (message.length % blockSize === 0);\n    }\n    const lastBlockIndex = blockCount - 1;\n    if (lastBlockCompleteFlag) {\n        lastBlock = xor(getMessageBlock(message, lastBlockIndex), subkeys.subkey1);\n    }\n    else {\n        lastBlock = xor(getPaddedMessageBlock(message, lastBlockIndex), subkeys.subkey2);\n    }\n    let x = zero;\n    let y;\n    for (let index = 0; index < lastBlockIndex; index++) {\n        y = xor(x, getMessageBlock(message, index));\n        x = aes(key, y);\n    }\n    y = xor(lastBlock, x);\n    return aes(key, y);\n}\nclass AesCmacProvider extends core.AesCmacProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length,\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onSign(algorithm, key, data) {\n        const result = aesCmac(getCryptoKey(key).data, Buffer$1.from(data));\n        return new Uint8Array(result).buffer;\n    }\n    async onVerify(algorithm, key, signature, data) {\n        const signature2 = await this.sign(algorithm, key, data);\n        return Buffer$1.from(signature).compare(Buffer$1.from(signature2)) === 0;\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\n\nclass AesCtrProvider extends core.AesCtrProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length,\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\n\nclass AesGcmProvider extends core.AesGcmProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length,\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\n\nclass AesKwProvider extends core.AesKwProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length,\n        }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\n\nclass AesEcbProvider extends core.AesEcbProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await AesCrypto.generateKey({\n            name: this.name,\n            length: algorithm.length,\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return AesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return AesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return AesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const res = await AesCrypto.importKey(format, keyData, { name: algorithm.name }, extractable, keyUsages);\n        return setCryptoKey(res);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof AesCryptoKey)) {\n            throw new TypeError(\"key: Is not a AesCryptoKey\");\n        }\n    }\n}\n\nclass DesCryptoKey extends SymmetricKey {\n    get alg() {\n        switch (this.algorithm.name.toUpperCase()) {\n            case \"DES-CBC\":\n                return `DES-CBC`;\n            case \"DES-EDE3-CBC\":\n                return `3DES-CBC`;\n            default:\n                throw new core.AlgorithmError(\"Unsupported algorithm name\");\n        }\n    }\n    set alg(value) {\n    }\n}\n__decorate([\n    JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\n], DesCryptoKey.prototype, \"data\", void 0);\n\nclass DesCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const key = new DesCryptoKey();\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto.randomBytes(algorithm.length >> 3);\n        return key;\n    }\n    static async exportKey(format, key) {\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                return JsonSerializer.toJSON(key);\n            case \"raw\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new core.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                key = JsonParser.fromJSON(keyData, { targetSchema: DesCryptoKey });\n                break;\n            case \"raw\":\n                key = new DesCryptoKey();\n                key.data = Buffer$1.from(keyData);\n                break;\n            default:\n                throw new core.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = algorithm;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async encrypt(algorithm, key, data) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"DES-CBC\":\n                return this.encryptDesCBC(algorithm, key, Buffer$1.from(data));\n            case \"DES-EDE3-CBC\":\n                return this.encryptDesEDE3CBC(algorithm, key, Buffer$1.from(data));\n            default:\n                throw new core.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        if (!(key instanceof DesCryptoKey)) {\n            throw new Error(\"key: Is not DesCryptoKey\");\n        }\n        switch (algorithm.name.toUpperCase()) {\n            case \"DES-CBC\":\n                return this.decryptDesCBC(algorithm, key, Buffer$1.from(data));\n            case \"DES-EDE3-CBC\":\n                return this.decryptDesEDE3CBC(algorithm, key, Buffer$1.from(data));\n            default:\n                throw new core.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encryptDesCBC(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = Buffer$1.concat([enc, cipher.final()]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptDesCBC(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`des-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = Buffer$1.concat([dec, decipher.final()]);\n        return new Uint8Array(dec).buffer;\n    }\n    static async encryptDesEDE3CBC(algorithm, key, data) {\n        const cipher = crypto.createCipheriv(`des-ede3-cbc`, key.data, Buffer$1.from(algorithm.iv));\n        let enc = cipher.update(data);\n        enc = Buffer$1.concat([enc, cipher.final()]);\n        const res = new Uint8Array(enc).buffer;\n        return res;\n    }\n    static async decryptDesEDE3CBC(algorithm, key, data) {\n        const decipher = crypto.createDecipheriv(`des-ede3-cbc`, key.data, new Uint8Array(algorithm.iv));\n        let dec = decipher.update(data);\n        dec = Buffer$1.concat([dec, decipher.final()]);\n        return new Uint8Array(dec).buffer;\n    }\n}\n\nclass DesCbcProvider extends core.DesProvider {\n    constructor() {\n        super(...arguments);\n        this.keySizeBits = 64;\n        this.ivSize = 8;\n        this.name = \"DES-CBC\";\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.generateKey({\n            name: this.name,\n            length: this.keySizeBits,\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return DesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);\n        if (key.data.length !== (this.keySizeBits >> 3)) {\n            throw new core.OperationError(\"keyData: Wrong key size\");\n        }\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\n        }\n    }\n}\n\nclass DesEde3CbcProvider extends core.DesProvider {\n    constructor() {\n        super(...arguments);\n        this.keySizeBits = 192;\n        this.ivSize = 8;\n        this.name = \"DES-EDE3-CBC\";\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.generateKey({\n            name: this.name,\n            length: this.keySizeBits,\n        }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    async onEncrypt(algorithm, key, data) {\n        return DesCrypto.encrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onDecrypt(algorithm, key, data) {\n        return DesCrypto.decrypt(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return DesCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await DesCrypto.importKey(format, keyData, { name: this.name, length: this.keySizeBits }, extractable, keyUsages);\n        if (key.data.length !== (this.keySizeBits >> 3)) {\n            throw new core.OperationError(\"keyData: Wrong key size\");\n        }\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof DesCryptoKey)) {\n            throw new TypeError(\"key: Is not a DesCryptoKey\");\n        }\n    }\n}\n\nfunction getJwkAlgorithm(algorithm) {\n    switch (algorithm.name.toUpperCase()) {\n        case \"RSA-OAEP\": {\n            const mdSize = /(\\d+)$/.exec(algorithm.hash.name)[1];\n            return `RSA-OAEP${mdSize !== \"1\" ? `-${mdSize}` : \"\"}`;\n        }\n        case \"RSASSA-PKCS1-V1_5\":\n            return `RS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\n        case \"RSA-PSS\":\n            return `PS${/(\\d+)$/.exec(algorithm.hash.name)[1]}`;\n        case \"RSA-PKCS1\":\n            return `RS1`;\n        default:\n            throw new core.OperationError(\"algorithm: Is not recognized\");\n    }\n}\n\nclass RsaPrivateKey extends AsymmetricKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = AsnParser.parse(this.data, core.asn1.PrivateKeyInfo);\n        return AsnParser.parse(keyInfo.privateKey, core.asn1.RsaPrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"RSA\",\n            alg: getJwkAlgorithm(this.algorithm),\n            key_ops: this.usages,\n            ext: this.extractable,\n        };\n        return Object.assign(json, JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        const key = JsonParser.fromJSON(json, { targetSchema: core.asn1.RsaPrivateKey });\n        const keyInfo = new core.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.privateKeyAlgorithm.parameters = null;\n        keyInfo.privateKey = AsnSerializer.serialize(key);\n        this.data = Buffer$1.from(AsnSerializer.serialize(keyInfo));\n    }\n}\n\nclass RsaPublicKey extends AsymmetricKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = AsnParser.parse(this.data, core.asn1.PublicKeyInfo);\n        return AsnParser.parse(keyInfo.publicKey, core.asn1.RsaPublicKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"RSA\",\n            alg: getJwkAlgorithm(this.algorithm),\n            key_ops: this.usages,\n            ext: this.extractable,\n        };\n        return Object.assign(json, JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        const key = JsonParser.fromJSON(json, { targetSchema: core.asn1.RsaPublicKey });\n        const keyInfo = new core.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.publicKeyAlgorithm.parameters = null;\n        keyInfo.publicKey = AsnSerializer.serialize(key);\n        this.data = Buffer$1.from(AsnSerializer.serialize(keyInfo));\n    }\n}\n\nclass RsaCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new RsaPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new RsaPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\n        const publicExponent = Buffer$1.concat([\n            Buffer$1.alloc(4 - algorithm.publicExponent.byteLength, 0),\n            Buffer$1.from(algorithm.publicExponent),\n        ]).readInt32BE(0);\n        const keys = crypto.generateKeyPairSync(\"rsa\", {\n            modulusLength: algorithm.modulusLength,\n            publicExponent,\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\",\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\",\n            },\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey,\n        };\n        return res;\n    }\n    static async exportKey(format, key) {\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                return JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            default:\n                throw new core.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch (format.toLowerCase()) {\n            case \"jwk\": {\n                const jwk = keyData;\n                if (jwk.d) {\n                    const asnKey = JsonParser.fromJSON(keyData, { targetSchema: core.asn1.RsaPrivateKey });\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n                else {\n                    const asnKey = JsonParser.fromJSON(keyData, { targetSchema: core.asn1.RsaPublicKey });\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            }\n            case \"spki\": {\n                const keyInfo = AsnParser.parse(new Uint8Array(keyData), core.asn1.PublicKeyInfo);\n                const asnKey = AsnParser.parse(keyInfo.publicKey, core.asn1.RsaPublicKey);\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n            }\n            case \"pkcs8\": {\n                const keyInfo = AsnParser.parse(new Uint8Array(keyData), core.asn1.PrivateKeyInfo);\n                const asnKey = AsnParser.parse(keyInfo.privateKey, core.asn1.RsaPrivateKey);\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n            }\n            default:\n                throw new core.OperationError(\"format: Must be 'jwk', 'pkcs8' or 'spki'\");\n        }\n    }\n    static async sign(algorithm, key, data) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"RSA-PSS\":\n            case \"RSASSA-PKCS1-V1_5\":\n                return this.signRsa(algorithm, key, data);\n            default:\n                throw new core.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async verify(algorithm, key, signature, data) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"RSA-PSS\":\n            case \"RSASSA-PKCS1-V1_5\":\n                return this.verifySSA(algorithm, key, data, signature);\n            default:\n                throw new core.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async encrypt(algorithm, key, data) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"RSA-OAEP\":\n                return this.encryptOAEP(algorithm, key, data);\n            default:\n                throw new core.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static async decrypt(algorithm, key, data) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"RSA-OAEP\":\n                return this.decryptOAEP(algorithm, key, data);\n            default:\n                throw new core.OperationError(\"algorithm: Is not recognized\");\n        }\n    }\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.privateKeyAlgorithm.parameters = null;\n        keyInfo.privateKey = AsnSerializer.serialize(asnKey);\n        const key = new RsaPrivateKey();\n        key.data = Buffer$1.from(AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.113549.1.1.1\";\n        keyInfo.publicKeyAlgorithm.parameters = null;\n        keyInfo.publicKey = AsnSerializer.serialize(asnKey);\n        const key = new RsaPublicKey();\n        key.data = Buffer$1.from(AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.algorithm.publicExponent = new Uint8Array(asnKey.publicExponent);\n        key.algorithm.modulusLength = asnKey.modulus.byteLength << 3;\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static getCryptoAlgorithm(alg) {\n        switch (alg.hash.name.toUpperCase()) {\n            case \"SHA-1\":\n                return \"RSA-SHA1\";\n            case \"SHA-256\":\n                return \"RSA-SHA256\";\n            case \"SHA-384\":\n                return \"RSA-SHA384\";\n            case \"SHA-512\":\n                return \"RSA-SHA512\";\n            case \"SHA3-256\":\n                return \"RSA-SHA3-256\";\n            case \"SHA3-384\":\n                return \"RSA-SHA3-384\";\n            case \"SHA3-512\":\n                return \"RSA-SHA3-512\";\n            default:\n                throw new core.OperationError(\"algorithm.hash: Is not recognized\");\n        }\n    }\n    static signRsa(algorithm, key, data) {\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\n        const signer = crypto.createSign(cryptoAlg);\n        signer.update(Buffer$1.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem,\n        };\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\n            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;\n            options.saltLength = algorithm.saltLength;\n        }\n        const signature = signer.sign(options);\n        return new Uint8Array(signature).buffer;\n    }\n    static verifySSA(algorithm, key, data, signature) {\n        const cryptoAlg = this.getCryptoAlgorithm(key.algorithm);\n        const signer = crypto.createVerify(cryptoAlg);\n        signer.update(Buffer$1.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem,\n        };\n        if (algorithm.name.toUpperCase() === \"RSA-PSS\") {\n            options.padding = crypto.constants.RSA_PKCS1_PSS_PADDING;\n            options.saltLength = algorithm.saltLength;\n        }\n        const ok = signer.verify(options, signature);\n        return ok;\n    }\n    static encryptOAEP(algorithm, key, data) {\n        const options = {\n            key: `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`,\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n        };\n        if (algorithm.label) ;\n        return new Uint8Array(crypto.publicEncrypt(options, data)).buffer;\n    }\n    static decryptOAEP(algorithm, key, data) {\n        const options = {\n            key: `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`,\n            padding: crypto.constants.RSA_PKCS1_OAEP_PADDING,\n        };\n        if (algorithm.label) ;\n        return new Uint8Array(crypto.privateDecrypt(options, data)).buffer;\n    }\n}\nRsaCrypto.publicKeyUsages = [\"verify\", \"encrypt\", \"wrapKey\"];\nRsaCrypto.privateKeyUsages = [\"sign\", \"decrypt\", \"unwrapKey\"];\n\nclass RsaSsaProvider extends core.RsaSsaProvider {\n    constructor() {\n        super(...arguments);\n        this.hashAlgorithms = [\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\n            \"shake128\", \"shake256\",\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name,\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n}\n\nclass RsaPssProvider extends core.RsaPssProvider {\n    constructor() {\n        super(...arguments);\n        this.hashAlgorithms = [\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\n            \"shake128\", \"shake256\",\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name,\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return RsaCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return RsaCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n}\n\nclass ShaCrypto {\n    static size(algorithm) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"SHA-1\":\n                return 160;\n            case \"SHA-256\":\n            case \"SHA3-256\":\n                return 256;\n            case \"SHA-384\":\n            case \"SHA3-384\":\n                return 384;\n            case \"SHA-512\":\n            case \"SHA3-512\":\n                return 512;\n            default:\n                throw new Error(\"Unrecognized name\");\n        }\n    }\n    static getAlgorithmName(algorithm) {\n        switch (algorithm.name.toUpperCase()) {\n            case \"SHA-1\":\n                return \"sha1\";\n            case \"SHA-256\":\n                return \"sha256\";\n            case \"SHA-384\":\n                return \"sha384\";\n            case \"SHA-512\":\n                return \"sha512\";\n            case \"SHA3-256\":\n                return \"sha3-256\";\n            case \"SHA3-384\":\n                return \"sha3-384\";\n            case \"SHA3-512\":\n                return \"sha3-512\";\n            default:\n                throw new Error(\"Unrecognized name\");\n        }\n    }\n    static digest(algorithm, data) {\n        const hashAlg = this.getAlgorithmName(algorithm);\n        const hash = crypto.createHash(hashAlg)\n            .update(Buffer$1.from(data)).digest();\n        return new Uint8Array(hash).buffer;\n    }\n}\n\nclass RsaOaepProvider extends core.RsaOaepProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name,\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onEncrypt(algorithm, key, data) {\n        const internalKey = getCryptoKey(key);\n        const dataView = new Uint8Array(data);\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\n        const dataLength = dataView.byteLength;\n        const psLength = keySize - dataLength - 2 * hashSize - 2;\n        if (dataLength > keySize - 2 * hashSize - 2) {\n            throw new Error(\"Data too large\");\n        }\n        const message = new Uint8Array(keySize);\n        const seed = message.subarray(1, hashSize + 1);\n        const dataBlock = message.subarray(hashSize + 1);\n        dataBlock.set(dataView, hashSize + psLength + 1);\n        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\"))\n            .update(core.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))\n            .digest();\n        dataBlock.set(labelHash, 0);\n        dataBlock[hashSize + psLength] = 1;\n        crypto.randomFillSync(seed);\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\n        for (let i = 0; i < dataBlock.length; i++) {\n            dataBlock[i] ^= dataBlockMask[i];\n        }\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\n        for (let i = 0; i < seed.length; i++) {\n            seed[i] ^= seedMask[i];\n        }\n        if (!internalKey.pem) {\n            internalKey.pem = `-----BEGIN PUBLIC KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const pkcs0 = crypto.publicEncrypt({\n            key: internalKey.pem,\n            padding: crypto.constants.RSA_NO_PADDING,\n        }, Buffer$1.from(message));\n        return new Uint8Array(pkcs0).buffer;\n    }\n    async onDecrypt(algorithm, key, data) {\n        const internalKey = getCryptoKey(key);\n        const keySize = Math.ceil(internalKey.algorithm.modulusLength >> 3);\n        const hashSize = ShaCrypto.size(internalKey.algorithm.hash) >> 3;\n        const dataLength = data.byteLength;\n        if (dataLength !== keySize) {\n            throw new Error(\"Bad data\");\n        }\n        if (!internalKey.pem) {\n            internalKey.pem = `-----BEGIN PRIVATE KEY-----\\n${internalKey.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        let pkcs0 = crypto.privateDecrypt({\n            key: internalKey.pem,\n            padding: crypto.constants.RSA_NO_PADDING,\n        }, Buffer$1.from(data));\n        const z = pkcs0[0];\n        const seed = pkcs0.subarray(1, hashSize + 1);\n        const dataBlock = pkcs0.subarray(hashSize + 1);\n        if (z !== 0) {\n            throw new Error(\"Decryption failed\");\n        }\n        const seedMask = this.mgf1(internalKey.algorithm.hash, dataBlock, seed.length);\n        for (let i = 0; i < seed.length; i++) {\n            seed[i] ^= seedMask[i];\n        }\n        const dataBlockMask = this.mgf1(internalKey.algorithm.hash, seed, dataBlock.length);\n        for (let i = 0; i < dataBlock.length; i++) {\n            dataBlock[i] ^= dataBlockMask[i];\n        }\n        const labelHash = crypto.createHash(internalKey.algorithm.hash.name.replace(\"-\", \"\"))\n            .update(core.BufferSourceConverter.toUint8Array(algorithm.label || new Uint8Array(0)))\n            .digest();\n        for (let i = 0; i < hashSize; i++) {\n            if (labelHash[i] !== dataBlock[i]) {\n                throw new Error(\"Decryption failed\");\n            }\n        }\n        let psEnd = hashSize;\n        for (; psEnd < dataBlock.length; psEnd++) {\n            const psz = dataBlock[psEnd];\n            if (psz === 1) {\n                break;\n            }\n            if (psz !== 0) {\n                throw new Error(\"Decryption failed\");\n            }\n        }\n        if (psEnd === dataBlock.length) {\n            throw new Error(\"Decryption failed\");\n        }\n        pkcs0 = dataBlock.subarray(psEnd + 1);\n        return new Uint8Array(pkcs0).buffer;\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n    mgf1(algorithm, seed, length = 0) {\n        const hashSize = ShaCrypto.size(algorithm) >> 3;\n        const mask = new Uint8Array(length);\n        const counter = new Uint8Array(4);\n        const chunks = Math.ceil(length / hashSize);\n        for (let i = 0; i < chunks; i++) {\n            counter[0] = i >>> 24;\n            counter[1] = (i >>> 16) & 255;\n            counter[2] = (i >>> 8) & 255;\n            counter[3] = i & 255;\n            const submask = mask.subarray(i * hashSize);\n            let chunk = crypto.createHash(algorithm.name.replace(\"-\", \"\"))\n                .update(seed)\n                .update(counter)\n                .digest();\n            if (chunk.length > submask.length) {\n                chunk = chunk.subarray(0, submask.length);\n            }\n            submask.set(chunk);\n        }\n        return mask;\n    }\n}\n\nclass RsaEsProvider extends core.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"RSAES-PKCS1-v1_5\";\n        this.usages = {\n            publicKey: [\"encrypt\", \"wrapKey\"],\n            privateKey: [\"decrypt\", \"unwrapKey\"],\n        };\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await RsaCrypto.generateKey({\n            ...algorithm,\n            name: this.name,\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    checkGenerateKeyParams(algorithm) {\n        this.checkRequiredProperty(algorithm, \"publicExponent\");\n        if (!(algorithm.publicExponent && algorithm.publicExponent instanceof Uint8Array)) {\n            throw new TypeError(\"publicExponent: Missing or not a Uint8Array\");\n        }\n        const publicExponent = Convert.ToBase64(algorithm.publicExponent);\n        if (!(publicExponent === \"Aw==\" || publicExponent === \"AQAB\")) {\n            throw new TypeError(\"publicExponent: Must be [3] or [1,0,1]\");\n        }\n        this.checkRequiredProperty(algorithm, \"modulusLength\");\n        switch (algorithm.modulusLength) {\n            case 1024:\n            case 2048:\n            case 4096:\n                break;\n            default:\n                throw new TypeError(\"modulusLength: Must be 1024, 2048, or 4096\");\n        }\n    }\n    async onEncrypt(algorithm, key, data) {\n        const options = this.toCryptoOptions(key);\n        const enc = crypto.publicEncrypt(options, new Uint8Array(data));\n        return new Uint8Array(enc).buffer;\n    }\n    async onDecrypt(algorithm, key, data) {\n        const options = this.toCryptoOptions(key);\n        const dec = crypto.privateDecrypt(options, new Uint8Array(data));\n        return new Uint8Array(dec).buffer;\n    }\n    async onExportKey(format, key) {\n        return RsaCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await RsaCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof RsaPrivateKey || internalKey instanceof RsaPublicKey)) {\n            throw new TypeError(\"key: Is not RSA CryptoKey\");\n        }\n    }\n    toCryptoOptions(key) {\n        const type = key.type.toUpperCase();\n        return {\n            key: `-----BEGIN ${type} KEY-----\\n${getCryptoKey(key).data.toString(\"base64\")}\\n-----END ${type} KEY-----`,\n            padding: crypto.constants.RSA_PKCS1_PADDING,\n        };\n    }\n}\n\nconst namedOIDs = {\n    \"1.2.840.10045.3.1.7\": \"P-256\",\n    \"P-256\": \"1.2.840.10045.3.1.7\",\n    \"1.3.132.0.34\": \"P-384\",\n    \"P-384\": \"1.3.132.0.34\",\n    \"1.3.132.0.35\": \"P-521\",\n    \"P-521\": \"1.3.132.0.35\",\n    \"1.3.132.0.10\": \"K-256\",\n    \"K-256\": \"1.3.132.0.10\",\n    \"brainpoolP160r1\": \"1.3.36.3.3.2.8.1.1.1\",\n    \"1.3.36.3.3.2.8.1.1.1\": \"brainpoolP160r1\",\n    \"brainpoolP160t1\": \"1.3.36.3.3.2.8.1.1.2\",\n    \"1.3.36.3.3.2.8.1.1.2\": \"brainpoolP160t1\",\n    \"brainpoolP192r1\": \"1.3.36.3.3.2.8.1.1.3\",\n    \"1.3.36.3.3.2.8.1.1.3\": \"brainpoolP192r1\",\n    \"brainpoolP192t1\": \"1.3.36.3.3.2.8.1.1.4\",\n    \"1.3.36.3.3.2.8.1.1.4\": \"brainpoolP192t1\",\n    \"brainpoolP224r1\": \"1.3.36.3.3.2.8.1.1.5\",\n    \"1.3.36.3.3.2.8.1.1.5\": \"brainpoolP224r1\",\n    \"brainpoolP224t1\": \"1.3.36.3.3.2.8.1.1.6\",\n    \"1.3.36.3.3.2.8.1.1.6\": \"brainpoolP224t1\",\n    \"brainpoolP256r1\": \"1.3.36.3.3.2.8.1.1.7\",\n    \"1.3.36.3.3.2.8.1.1.7\": \"brainpoolP256r1\",\n    \"brainpoolP256t1\": \"1.3.36.3.3.2.8.1.1.8\",\n    \"1.3.36.3.3.2.8.1.1.8\": \"brainpoolP256t1\",\n    \"brainpoolP320r1\": \"1.3.36.3.3.2.8.1.1.9\",\n    \"1.3.36.3.3.2.8.1.1.9\": \"brainpoolP320r1\",\n    \"brainpoolP320t1\": \"1.3.36.3.3.2.8.1.1.10\",\n    \"1.3.36.3.3.2.8.1.1.10\": \"brainpoolP320t1\",\n    \"brainpoolP384r1\": \"1.3.36.3.3.2.8.1.1.11\",\n    \"1.3.36.3.3.2.8.1.1.11\": \"brainpoolP384r1\",\n    \"brainpoolP384t1\": \"1.3.36.3.3.2.8.1.1.12\",\n    \"1.3.36.3.3.2.8.1.1.12\": \"brainpoolP384t1\",\n    \"brainpoolP512r1\": \"1.3.36.3.3.2.8.1.1.13\",\n    \"1.3.36.3.3.2.8.1.1.13\": \"brainpoolP512r1\",\n    \"brainpoolP512t1\": \"1.3.36.3.3.2.8.1.1.14\",\n    \"1.3.36.3.3.2.8.1.1.14\": \"brainpoolP512t1\",\n};\nfunction getOidByNamedCurve$1(namedCurve) {\n    const oid = namedOIDs[namedCurve];\n    if (!oid) {\n        throw new core.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\n    }\n    return oid;\n}\n\nclass EcPrivateKey extends AsymmetricKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = AsnParser.parse(this.data, core.asn1.PrivateKeyInfo);\n        return AsnParser.parse(keyInfo.privateKey, core.asn1.EcPrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"EC\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable,\n        };\n        return Object.assign(json, JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const keyInfo = new core.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.privateKeyAlgorithm.parameters = AsnSerializer.serialize(new core.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\n        const key = JsonParser.fromJSON(json, { targetSchema: core.asn1.EcPrivateKey });\n        keyInfo.privateKey = AsnSerializer.serialize(key);\n        this.data = Buffer$1.from(AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\n\nclass EcPublicKey extends AsymmetricKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = AsnParser.parse(this.data, core.asn1.PublicKeyInfo);\n        return new core.asn1.EcPublicKey(keyInfo.publicKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"EC\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable,\n        };\n        return Object.assign(json, JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const key = JsonParser.fromJSON(json, { targetSchema: core.asn1.EcPublicKey });\n        const keyInfo = new core.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.publicKeyAlgorithm.parameters = AsnSerializer.serialize(new core.asn1.ObjectIdentifier(getOidByNamedCurve$1(json.crv)));\n        keyInfo.publicKey = AsnSerializer.toASN(key).valueHex;\n        this.data = Buffer$1.from(AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\n\nclass Sha1Provider extends core.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"SHA-1\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\n\nclass Sha256Provider extends core.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"SHA-256\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\n\nclass Sha384Provider extends core.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"SHA-384\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\n\nclass Sha512Provider extends core.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"SHA-512\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\n\nclass Sha3256Provider extends core.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"SHA3-256\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\n\nclass Sha3384Provider extends core.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"SHA3-384\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\n\nclass Sha3512Provider extends core.ProviderCrypto {\n    constructor() {\n        super(...arguments);\n        this.name = \"SHA3-512\";\n        this.usages = [];\n    }\n    async onDigest(algorithm, data) {\n        return ShaCrypto.digest(algorithm, data);\n    }\n}\n\nclass EcCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new EcPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new EcPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\n        const keys = crypto.generateKeyPairSync(\"ec\", {\n            namedCurve: this.getOpenSSLNamedCurve(algorithm.namedCurve),\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\",\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\",\n            },\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey,\n        };\n        return res;\n    }\n    static async sign(algorithm, key, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\n        const signer = crypto.createSign(cryptoAlg);\n        signer.update(Buffer$1.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem,\n        };\n        const signature = signer.sign(options);\n        const ecSignature = AsnParser.parse(signature, core.asn1.EcDsaSignature);\n        const signatureRaw = core.EcUtils.encodeSignature(ecSignature, core.EcCurves.get(key.algorithm.namedCurve).size);\n        return signatureRaw.buffer;\n    }\n    static async verify(algorithm, key, signature, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(algorithm.hash);\n        const signer = crypto.createVerify(cryptoAlg);\n        signer.update(Buffer$1.from(data));\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem,\n        };\n        const ecSignature = new core.asn1.EcDsaSignature();\n        const namedCurve = core.EcCurves.get(key.algorithm.namedCurve);\n        const signaturePoint = core.EcUtils.decodeSignature(signature, namedCurve.size);\n        ecSignature.r = BufferSourceConverter.toArrayBuffer(signaturePoint.r);\n        ecSignature.s = BufferSourceConverter.toArrayBuffer(signaturePoint.s);\n        const ecSignatureRaw = Buffer$1.from(AsnSerializer.serialize(ecSignature));\n        const ok = signer.verify(options, ecSignatureRaw);\n        return ok;\n    }\n    static async deriveBits(algorithm, baseKey, length) {\n        const cryptoAlg = this.getOpenSSLNamedCurve(baseKey.algorithm.namedCurve);\n        const ecdh = crypto.createECDH(cryptoAlg);\n        const asnPrivateKey = AsnParser.parse(baseKey.data, core.asn1.PrivateKeyInfo);\n        const asnEcPrivateKey = AsnParser.parse(asnPrivateKey.privateKey, core.asn1.EcPrivateKey);\n        ecdh.setPrivateKey(Buffer$1.from(asnEcPrivateKey.privateKey));\n        const asnPublicKey = AsnParser.parse(algorithm.public.data, core.asn1.PublicKeyInfo);\n        const bits = ecdh.computeSecret(Buffer$1.from(asnPublicKey.publicKey));\n        if (length === null) {\n            return bits;\n        }\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\n    }\n    static async exportKey(format, key) {\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                return JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            case \"raw\": {\n                const publicKeyInfo = AsnParser.parse(key.data, core.asn1.PublicKeyInfo);\n                return publicKeyInfo.publicKey;\n            }\n            default:\n                throw new core.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch (format.toLowerCase()) {\n            case \"jwk\": {\n                const jwk = keyData;\n                if (jwk.d) {\n                    const asnKey = JsonParser.fromJSON(keyData, { targetSchema: core.asn1.EcPrivateKey });\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n                else {\n                    const asnKey = JsonParser.fromJSON(keyData, { targetSchema: core.asn1.EcPublicKey });\n                    return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n                }\n            }\n            case \"raw\": {\n                const asnKey = new core.asn1.EcPublicKey(keyData);\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n            }\n            case \"spki\": {\n                const keyInfo = AsnParser.parse(new Uint8Array(keyData), core.asn1.PublicKeyInfo);\n                const asnKey = new core.asn1.EcPublicKey(keyInfo.publicKey);\n                this.assertKeyParameters(keyInfo.publicKeyAlgorithm.parameters, algorithm.namedCurve);\n                return this.importPublicKey(asnKey, algorithm, extractable, keyUsages);\n            }\n            case \"pkcs8\": {\n                const keyInfo = AsnParser.parse(new Uint8Array(keyData), core.asn1.PrivateKeyInfo);\n                const asnKey = AsnParser.parse(keyInfo.privateKey, core.asn1.EcPrivateKey);\n                this.assertKeyParameters(keyInfo.privateKeyAlgorithm.parameters, algorithm.namedCurve);\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n            }\n            default:\n                throw new core.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\n        }\n    }\n    static assertKeyParameters(parameters, namedCurve) {\n        if (!parameters) {\n            throw new core.CryptoError(\"Key info doesn't have required parameters\");\n        }\n        let namedCurveIdentifier = \"\";\n        try {\n            namedCurveIdentifier = AsnParser.parse(parameters, core.asn1.ObjectIdentifier).value;\n        }\n        catch (e) {\n            throw new core.CryptoError(\"Cannot read key info parameters\");\n        }\n        if (getOidByNamedCurve$1(namedCurve) !== namedCurveIdentifier) {\n            throw new core.CryptoError(\"Key info parameter doesn't match to named curve\");\n        }\n    }\n    static async importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        keyInfo.privateKeyAlgorithm.parameters = AsnSerializer.serialize(new core.asn1.ObjectIdentifier(getOidByNamedCurve$1(algorithm.namedCurve)));\n        keyInfo.privateKey = AsnSerializer.serialize(asnKey);\n        const key = new EcPrivateKey();\n        key.data = Buffer$1.from(AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const keyInfo = new core.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = \"1.2.840.10045.2.1\";\n        const namedCurve = getOidByNamedCurve$1(algorithm.namedCurve);\n        keyInfo.publicKeyAlgorithm.parameters = AsnSerializer.serialize(new core.asn1.ObjectIdentifier(namedCurve));\n        keyInfo.publicKey = asnKey.value;\n        const key = new EcPublicKey();\n        key.data = Buffer$1.from(AsnSerializer.serialize(keyInfo));\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static getOpenSSLNamedCurve(curve) {\n        switch (curve.toUpperCase()) {\n            case \"P-256\":\n                return \"prime256v1\";\n            case \"K-256\":\n                return \"secp256k1\";\n            case \"P-384\":\n                return \"secp384r1\";\n            case \"P-521\":\n                return \"secp521r1\";\n            default:\n                return curve;\n        }\n    }\n}\nEcCrypto.publicKeyUsages = [\"verify\"];\nEcCrypto.privateKeyUsages = [\"sign\", \"deriveKey\", \"deriveBits\"];\n\nclass EcdsaProvider extends core.EcdsaProvider {\n    constructor() {\n        super(...arguments);\n        this.namedCurves = core.EcCurves.names;\n        this.hashAlgorithms = [\n            \"SHA-1\", \"SHA-256\", \"SHA-384\", \"SHA-512\",\n            \"shake128\", \"shake256\",\n            \"SHA3-256\", \"SHA3-384\", \"SHA3-512\"\n        ];\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EcCrypto.generateKey({\n            ...algorithm,\n            name: this.name,\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return EcCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return EcCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return EcCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\n            throw new TypeError(\"key: Is not EC CryptoKey\");\n        }\n    }\n}\n\nclass EcdhProvider extends core.EcdhProvider {\n    constructor() {\n        super(...arguments);\n        this.namedCurves = core.EcCurves.names;\n    }\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EcCrypto.generateKey({\n            ...algorithm,\n            name: this.name,\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onExportKey(format, key) {\n        return EcCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EcCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        const internalKey = getCryptoKey(key);\n        if (!(internalKey instanceof EcPrivateKey || internalKey instanceof EcPublicKey)) {\n            throw new TypeError(\"key: Is not EC CryptoKey\");\n        }\n    }\n    async onDeriveBits(algorithm, baseKey, length) {\n        const bits = await EcCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);\n        return bits;\n    }\n}\n\nconst edOIDs = {\n    [core.asn1.idEd448]: \"Ed448\",\n    \"ed448\": core.asn1.idEd448,\n    [core.asn1.idX448]: \"X448\",\n    \"x448\": core.asn1.idX448,\n    [core.asn1.idEd25519]: \"Ed25519\",\n    \"ed25519\": core.asn1.idEd25519,\n    [core.asn1.idX25519]: \"X25519\",\n    \"x25519\": core.asn1.idX25519,\n};\nfunction getOidByNamedCurve(namedCurve) {\n    const oid = edOIDs[namedCurve.toLowerCase()];\n    if (!oid) {\n        throw new core.OperationError(`Cannot convert WebCrypto named curve '${namedCurve}' to OID`);\n    }\n    return oid;\n}\n\nclass EdPrivateKey extends AsymmetricKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"private\";\n    }\n    getKey() {\n        const keyInfo = AsnParser.parse(this.data, core.asn1.PrivateKeyInfo);\n        return AsnParser.parse(keyInfo.privateKey, core.asn1.CurvePrivateKey);\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"OKP\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable,\n        };\n        return Object.assign(json, JsonSerializer.toJSON(key));\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        const keyInfo = new core.asn1.PrivateKeyInfo();\n        keyInfo.privateKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\n        const key = JsonParser.fromJSON(json, { targetSchema: core.asn1.CurvePrivateKey });\n        keyInfo.privateKey = AsnSerializer.serialize(key);\n        this.data = Buffer$1.from(AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\n\nclass EdPublicKey extends AsymmetricKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"public\";\n    }\n    getKey() {\n        const keyInfo = AsnParser.parse(this.data, core.asn1.PublicKeyInfo);\n        return keyInfo.publicKey;\n    }\n    toJSON() {\n        const key = this.getKey();\n        const json = {\n            kty: \"OKP\",\n            crv: this.algorithm.namedCurve,\n            key_ops: this.usages,\n            ext: this.extractable,\n        };\n        return Object.assign(json, {\n            x: Convert.ToBase64Url(key)\n        });\n    }\n    fromJSON(json) {\n        if (!json.crv) {\n            throw new core.OperationError(`Cannot get named curve from JWK. Property 'crv' is required`);\n        }\n        if (!json.x) {\n            throw new core.OperationError(`Cannot get property from JWK. Property 'x' is required`);\n        }\n        const keyInfo = new core.asn1.PublicKeyInfo();\n        keyInfo.publicKeyAlgorithm.algorithm = getOidByNamedCurve(json.crv);\n        keyInfo.publicKey = Convert.FromBase64Url(json.x);\n        this.data = Buffer$1.from(AsnSerializer.serialize(keyInfo));\n        return this;\n    }\n}\n\nclass EdCrypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const privateKey = new EdPrivateKey();\n        privateKey.algorithm = algorithm;\n        privateKey.extractable = extractable;\n        privateKey.usages = keyUsages.filter((usage) => this.privateKeyUsages.indexOf(usage) !== -1);\n        const publicKey = new EdPublicKey();\n        publicKey.algorithm = algorithm;\n        publicKey.extractable = true;\n        publicKey.usages = keyUsages.filter((usage) => this.publicKeyUsages.indexOf(usage) !== -1);\n        const type = algorithm.namedCurve.toLowerCase();\n        const keys = crypto.generateKeyPairSync(type, {\n            publicKeyEncoding: {\n                format: \"der\",\n                type: \"spki\",\n            },\n            privateKeyEncoding: {\n                format: \"der\",\n                type: \"pkcs8\",\n            },\n        });\n        privateKey.data = keys.privateKey;\n        publicKey.data = keys.publicKey;\n        const res = {\n            privateKey,\n            publicKey,\n        };\n        return res;\n    }\n    static async sign(algorithm, key, data) {\n        if (!key.pem) {\n            key.pem = `-----BEGIN PRIVATE KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PRIVATE KEY-----`;\n        }\n        const options = {\n            key: key.pem,\n        };\n        const signature = crypto.sign(null, Buffer$1.from(data), options);\n        return core.BufferSourceConverter.toArrayBuffer(signature);\n    }\n    static async verify(algorithm, key, signature, data) {\n        if (!key.pem) {\n            key.pem = `-----BEGIN PUBLIC KEY-----\\n${key.data.toString(\"base64\")}\\n-----END PUBLIC KEY-----`;\n        }\n        const options = {\n            key: key.pem,\n        };\n        const ok = crypto.verify(null, Buffer$1.from(data), options, Buffer$1.from(signature));\n        return ok;\n    }\n    static async deriveBits(algorithm, baseKey, length) {\n        const publicKey = crypto.createPublicKey({\n            key: algorithm.public.data,\n            format: \"der\",\n            type: \"spki\",\n        });\n        const privateKey = crypto.createPrivateKey({\n            key: baseKey.data,\n            format: \"der\",\n            type: \"pkcs8\",\n        });\n        const bits = crypto.diffieHellman({\n            publicKey,\n            privateKey,\n        });\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\n    }\n    static async exportKey(format, key) {\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                return JsonSerializer.toJSON(key);\n            case \"pkcs8\":\n            case \"spki\":\n                return new Uint8Array(key.data).buffer;\n            case \"raw\": {\n                const publicKeyInfo = AsnParser.parse(key.data, core.asn1.PublicKeyInfo);\n                return publicKeyInfo.publicKey;\n            }\n            default:\n                throw new core.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\");\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch (format.toLowerCase()) {\n            case \"jwk\": {\n                const jwk = keyData;\n                if (jwk.d) {\n                    const asnKey = JsonParser.fromJSON(keyData, { targetSchema: core.asn1.CurvePrivateKey });\n                    return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n                }\n                else {\n                    if (!jwk.x) {\n                        throw new TypeError(\"keyData: Cannot get required 'x' filed\");\n                    }\n                    return this.importPublicKey(Convert.FromBase64Url(jwk.x), algorithm, extractable, keyUsages);\n                }\n            }\n            case \"raw\": {\n                return this.importPublicKey(keyData, algorithm, extractable, keyUsages);\n            }\n            case \"spki\": {\n                const keyInfo = AsnParser.parse(new Uint8Array(keyData), core.asn1.PublicKeyInfo);\n                return this.importPublicKey(keyInfo.publicKey, algorithm, extractable, keyUsages);\n            }\n            case \"pkcs8\": {\n                const keyInfo = AsnParser.parse(new Uint8Array(keyData), core.asn1.PrivateKeyInfo);\n                const asnKey = AsnParser.parse(keyInfo.privateKey, core.asn1.CurvePrivateKey);\n                return this.importPrivateKey(asnKey, algorithm, extractable, keyUsages);\n            }\n            default:\n                throw new core.OperationError(\"format: Must be 'jwk', 'raw', 'pkcs8' or 'spki'\");\n        }\n    }\n    static importPrivateKey(asnKey, algorithm, extractable, keyUsages) {\n        const key = new EdPrivateKey();\n        key.fromJSON({\n            crv: algorithm.namedCurve,\n            d: Convert.ToBase64Url(asnKey.d),\n        });\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n    static async importPublicKey(asnKey, algorithm, extractable, keyUsages) {\n        const key = new EdPublicKey();\n        key.fromJSON({\n            crv: algorithm.namedCurve,\n            x: Convert.ToBase64Url(asnKey),\n        });\n        key.algorithm = Object.assign({}, algorithm);\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return key;\n    }\n}\nEdCrypto.publicKeyUsages = [\"verify\"];\nEdCrypto.privateKeyUsages = [\"sign\", \"deriveKey\", \"deriveBits\"];\n\nclass EdDsaProvider extends core.EdDsaProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EdCrypto.generateKey({\n            name: this.name,\n            namedCurve: algorithm.namedCurve.replace(/^ed/i, \"Ed\"),\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onSign(algorithm, key, data) {\n        return EdCrypto.sign(algorithm, getCryptoKey(key), new Uint8Array(data));\n    }\n    async onVerify(algorithm, key, signature, data) {\n        return EdCrypto.verify(algorithm, getCryptoKey(key), new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        return EdCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n}\n\nclass EcdhEsProvider extends core.EcdhEsProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await EdCrypto.generateKey({\n            name: this.name,\n            namedCurve: algorithm.namedCurve.toUpperCase(),\n        }, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onDeriveBits(algorithm, baseKey, length) {\n        const bits = await EdCrypto.deriveBits({ ...algorithm, public: getCryptoKey(algorithm.public) }, getCryptoKey(baseKey), length);\n        return bits;\n    }\n    async onExportKey(format, key) {\n        return EdCrypto.exportKey(format, getCryptoKey(key));\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await EdCrypto.importKey(format, keyData, { ...algorithm, name: this.name }, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n}\n\nclass Ed25519CryptoKey extends CryptoKey {\n    constructor(algorithm, extractable, usages, data) {\n        super();\n        this.algorithm = algorithm;\n        this.extractable = extractable;\n        this.usages = usages;\n        this.data = Buffer.from(data);\n    }\n    toJWK() {\n        return {\n            kty: \"OKP\",\n            crv: this.algorithm.name,\n            key_ops: this.usages,\n            ext: this.extractable,\n        };\n    }\n}\n\nclass Ed25519PrivateKey extends Ed25519CryptoKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"private\";\n    }\n    toJWK() {\n        const pubJwk = crypto.createPublicKey({\n            key: this.data,\n            format: \"pem\",\n        }).export({ format: \"jwk\" });\n        const raw = core.PemConverter.toUint8Array(this.data.toString());\n        const pkcs8 = AsnConvert.parse(raw, core.asn1.PrivateKeyInfo);\n        const d = AsnConvert.parse(pkcs8.privateKey, core.asn1.EdPrivateKey).value;\n        return {\n            ...super.toJWK(),\n            ...pubJwk,\n            d: Buffer.from(new Uint8Array(d)).toString(\"base64url\"),\n        };\n    }\n}\n\nclass Ed25519PublicKey extends Ed25519CryptoKey {\n    constructor() {\n        super(...arguments);\n        this.type = \"public\";\n    }\n    toJWK() {\n        const jwk = crypto.createPublicKey({\n            key: this.data,\n            format: \"pem\",\n        }).export({ format: \"jwk\" });\n        return {\n            ...super.toJWK(),\n            ...jwk,\n        };\n    }\n}\n\nclass Ed25519Crypto {\n    static async generateKey(algorithm, extractable, keyUsages) {\n        const type = algorithm.name.toLowerCase();\n        const keys = crypto.generateKeyPairSync(type, {\n            publicKeyEncoding: {\n                format: \"pem\",\n                type: \"spki\",\n            },\n            privateKeyEncoding: {\n                format: \"pem\",\n                type: \"pkcs8\",\n            },\n        });\n        const keyAlg = {\n            name: type === \"ed25519\" ? \"Ed25519\" : \"X25519\",\n        };\n        const privateKeyUsages = keyUsages.filter((usage) => this.privateKeyUsages.includes(usage));\n        const publicKeyUsages = keyUsages.filter((usage) => this.publicKeyUsages.includes(usage));\n        return {\n            privateKey: new Ed25519PrivateKey(keyAlg, extractable, privateKeyUsages, keys.privateKey),\n            publicKey: new Ed25519PublicKey(keyAlg, true, publicKeyUsages, keys.publicKey),\n        };\n    }\n    static async sign(algorithm, key, data) {\n        const signature = crypto.sign(null, Buffer.from(data), key.data);\n        return core.BufferSourceConverter.toArrayBuffer(signature);\n    }\n    static async verify(algorithm, key, signature, data) {\n        return crypto.verify(null, Buffer.from(data), key.data, signature);\n    }\n    static async exportKey(format, key) {\n        switch (format) {\n            case \"jwk\":\n                return key.toJWK();\n            case \"pkcs8\": {\n                return core.PemConverter.toArrayBuffer(key.data.toString());\n            }\n            case \"spki\": {\n                return core.PemConverter.toArrayBuffer(key.data.toString());\n            }\n            case \"raw\": {\n                const jwk = key.toJWK();\n                return Convert.FromBase64Url(jwk.x);\n            }\n            default:\n                return Promise.reject(new core.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\"));\n        }\n    }\n    static async importKey(format, keyData, algorithm, extractable, keyUsages) {\n        switch (format) {\n            case \"jwk\": {\n                const jwk = keyData;\n                if (jwk.d) {\n                    const privateData = new core.asn1.EdPrivateKey();\n                    privateData.value = core.BufferSourceConverter.toArrayBuffer(Buffer.from(jwk.d, \"base64url\"));\n                    const pkcs8 = new core.asn1.PrivateKeyInfo();\n                    pkcs8.privateKeyAlgorithm.algorithm = algorithm.name.toLowerCase() === \"ed25519\"\n                        ? core.asn1.idEd25519\n                        : core.asn1.idX25519;\n                    pkcs8.privateKey = AsnConvert.serialize(privateData);\n                    const raw = AsnConvert.serialize(pkcs8);\n                    const pem = core.PemConverter.fromBufferSource(raw, \"PRIVATE KEY\");\n                    return new Ed25519PrivateKey(algorithm, extractable, keyUsages, pem);\n                }\n                else if (jwk.x) {\n                    const pubKey = crypto.createPublicKey({\n                        format: \"jwk\",\n                        key: jwk,\n                    });\n                    const pem = pubKey.export({ format: \"pem\", type: \"spki\" });\n                    return new Ed25519PublicKey(algorithm, extractable, keyUsages, pem);\n                }\n                else {\n                    throw new core.OperationError(\"keyData: Cannot import JWK. 'd' or 'x' must be presented\");\n                }\n            }\n            case \"pkcs8\": {\n                const pem = core.PemConverter.fromBufferSource(keyData, \"PRIVATE KEY\");\n                return new Ed25519PrivateKey(algorithm, extractable, keyUsages, pem);\n            }\n            case \"spki\": {\n                const pem = core.PemConverter.fromBufferSource(keyData, \"PUBLIC KEY\");\n                return new Ed25519PublicKey(algorithm, extractable, keyUsages, pem);\n            }\n            case \"raw\": {\n                const raw = keyData;\n                const key = crypto.createPublicKey({\n                    format: \"jwk\",\n                    key: {\n                        kty: \"OKP\",\n                        crv: algorithm.name.toLowerCase() === \"ed25519\" ? \"Ed25519\" : \"X25519\",\n                        x: Convert.ToBase64Url(raw),\n                    },\n                });\n                const pem = key.export({ format: \"pem\", type: \"spki\" });\n                return new Ed25519PublicKey(algorithm, extractable, keyUsages, pem);\n            }\n            default:\n                return Promise.reject(new core.OperationError(\"format: Must be 'jwk', 'raw', pkcs8' or 'spki'\"));\n        }\n    }\n}\nEd25519Crypto.privateKeyUsages = [\"sign\", \"deriveBits\", \"deriveKey\"];\nEd25519Crypto.publicKeyUsages = [\"verify\"];\n\nclass Ed25519Provider extends core.Ed25519Provider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await Ed25519Crypto.generateKey(algorithm, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onSign(algorithm, key, data) {\n        const internalKey = getCryptoKey(key);\n        const signature = Ed25519Crypto.sign(algorithm, internalKey, new Uint8Array(data));\n        return signature;\n    }\n    onVerify(algorithm, key, signature, data) {\n        const internalKey = getCryptoKey(key);\n        return Ed25519Crypto.verify(algorithm, internalKey, new Uint8Array(signature), new Uint8Array(data));\n    }\n    async onExportKey(format, key) {\n        const internalKey = getCryptoKey(key);\n        return Ed25519Crypto.exportKey(format, internalKey);\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const internalKey = await Ed25519Crypto.importKey(format, keyData, algorithm, extractable, keyUsages);\n        return setCryptoKey(internalKey);\n    }\n}\n\nclass X25519Provider extends core.X25519Provider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const keys = await Ed25519Crypto.generateKey(algorithm, extractable, keyUsages);\n        return {\n            privateKey: setCryptoKey(keys.privateKey),\n            publicKey: setCryptoKey(keys.publicKey),\n        };\n    }\n    async onDeriveBits(algorithm, baseKey, length) {\n        const internalBaseKey = getCryptoKey(baseKey);\n        const internalPublicKey = getCryptoKey(algorithm.public);\n        const publicKey = crypto.createPublicKey({\n            key: internalPublicKey.data.toString(),\n            format: \"pem\",\n            type: \"spki\",\n        });\n        const privateKey = crypto.createPrivateKey({\n            key: internalBaseKey.data.toString(),\n            format: \"pem\",\n            type: \"pkcs8\",\n        });\n        const bits = crypto.diffieHellman({\n            publicKey,\n            privateKey,\n        });\n        return new Uint8Array(bits).buffer.slice(0, length >> 3);\n    }\n    async onExportKey(format, key) {\n        const internalKey = getCryptoKey(key);\n        return Ed25519Crypto.exportKey(format, internalKey);\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        const key = await Ed25519Crypto.importKey(format, keyData, algorithm, extractable, keyUsages);\n        return setCryptoKey(key);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof Ed25519CryptoKey)) {\n            throw new TypeError(\"key: Is not a Ed25519CryptoKey\");\n        }\n    }\n}\n\nclass PbkdfCryptoKey extends CryptoKey {\n}\n\nclass Pbkdf2Provider extends core.Pbkdf2Provider {\n    async onDeriveBits(algorithm, baseKey, length) {\n        return new Promise((resolve, reject) => {\n            const salt = core.BufferSourceConverter.toArrayBuffer(algorithm.salt);\n            const hash = algorithm.hash.name.replace(\"-\", \"\");\n            crypto.pbkdf2(getCryptoKey(baseKey).data, Buffer$1.from(salt), algorithm.iterations, length >> 3, hash, (err, derivedBits) => {\n                if (err) {\n                    reject(err);\n                }\n                else {\n                    resolve(new Uint8Array(derivedBits).buffer);\n                }\n            });\n        });\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        if (format === \"raw\") {\n            const key = new PbkdfCryptoKey();\n            key.data = Buffer$1.from(keyData);\n            key.algorithm = { name: this.name };\n            key.extractable = false;\n            key.usages = keyUsages;\n            return setCryptoKey(key);\n        }\n        throw new core.OperationError(\"format: Must be 'raw'\");\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof PbkdfCryptoKey)) {\n            throw new TypeError(\"key: Is not PBKDF CryptoKey\");\n        }\n    }\n}\n\nclass HmacCryptoKey extends CryptoKey {\n    get alg() {\n        const hash = this.algorithm.hash.name.toUpperCase();\n        return `HS${hash.replace(\"SHA-\", \"\")}`;\n    }\n    set alg(value) {\n    }\n}\n__decorate([\n    JsonProp({ name: \"k\", converter: JsonBase64UrlConverter })\n], HmacCryptoKey.prototype, \"data\", void 0);\n\nclass HmacProvider extends core.HmacProvider {\n    async onGenerateKey(algorithm, extractable, keyUsages) {\n        const length = (algorithm.length || this.getDefaultLength(algorithm.hash.name)) >> 3 << 3;\n        const key = new HmacCryptoKey();\n        key.algorithm = {\n            ...algorithm,\n            length,\n            name: this.name,\n        };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        key.data = crypto.randomBytes(length >> 3);\n        return setCryptoKey(key);\n    }\n    async onSign(algorithm, key, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\n        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data)\n            .update(Buffer$1.from(data)).digest();\n        return new Uint8Array(hmac).buffer;\n    }\n    async onVerify(algorithm, key, signature, data) {\n        const cryptoAlg = ShaCrypto.getAlgorithmName(key.algorithm.hash);\n        const hmac = crypto.createHmac(cryptoAlg, getCryptoKey(key).data)\n            .update(Buffer$1.from(data)).digest();\n        return hmac.compare(Buffer$1.from(signature)) === 0;\n    }\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        let key;\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                key = JsonParser.fromJSON(keyData, { targetSchema: HmacCryptoKey });\n                break;\n            case \"raw\":\n                key = new HmacCryptoKey();\n                key.data = Buffer$1.from(keyData);\n                break;\n            default:\n                throw new core.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n        key.algorithm = {\n            hash: { name: algorithm.hash.name },\n            name: this.name,\n            length: key.data.length << 3,\n        };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return setCryptoKey(key);\n    }\n    async onExportKey(format, key) {\n        switch (format.toLowerCase()) {\n            case \"jwk\":\n                return JsonSerializer.toJSON(getCryptoKey(key));\n            case \"raw\":\n                return new Uint8Array(getCryptoKey(key).data).buffer;\n            default:\n                throw new core.OperationError(\"format: Must be 'jwk' or 'raw'\");\n        }\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof HmacCryptoKey)) {\n            throw new TypeError(\"key: Is not HMAC CryptoKey\");\n        }\n    }\n}\n\nclass HkdfCryptoKey extends CryptoKey {\n}\n\nclass HkdfProvider extends core.HkdfProvider {\n    async onImportKey(format, keyData, algorithm, extractable, keyUsages) {\n        if (format.toLowerCase() !== \"raw\") {\n            throw new core.OperationError(\"Operation not supported\");\n        }\n        const key = new HkdfCryptoKey();\n        key.data = Buffer$1.from(keyData);\n        key.algorithm = { name: this.name };\n        key.extractable = extractable;\n        key.usages = keyUsages;\n        return setCryptoKey(key);\n    }\n    async onDeriveBits(params, baseKey, length) {\n        const hash = params.hash.name.replace(\"-\", \"\");\n        const hashLength = crypto.createHash(hash).digest().length;\n        const byteLength = length / 8;\n        const info = BufferSourceConverter$1.toUint8Array(params.info);\n        const PRK = crypto.createHmac(hash, BufferSourceConverter$1.toUint8Array(params.salt))\n            .update(BufferSourceConverter$1.toUint8Array(getCryptoKey(baseKey).data))\n            .digest();\n        const blocks = [Buffer$1.alloc(0)];\n        const blockCount = Math.ceil(byteLength / hashLength) + 1;\n        for (let i = 1; i < blockCount; ++i) {\n            blocks.push(crypto.createHmac(hash, PRK)\n                .update(Buffer$1.concat([blocks[i - 1], info, Buffer$1.from([i])]))\n                .digest());\n        }\n        return Buffer$1.concat(blocks).slice(0, byteLength);\n    }\n    checkCryptoKey(key, keyUsage) {\n        super.checkCryptoKey(key, keyUsage);\n        if (!(getCryptoKey(key) instanceof HkdfCryptoKey)) {\n            throw new TypeError(\"key: Is not HKDF CryptoKey\");\n        }\n    }\n}\n\nclass ShakeCrypto {\n    static digest(algorithm, data) {\n        const hash = crypto.createHash(algorithm.name.toLowerCase(), { outputLength: algorithm.length })\n            .update(Buffer$1.from(data)).digest();\n        return new Uint8Array(hash).buffer;\n    }\n}\n\nclass Shake128Provider extends core.Shake128Provider {\n    async onDigest(algorithm, data) {\n        return ShakeCrypto.digest(algorithm, data);\n    }\n}\n\nclass Shake256Provider extends core.Shake256Provider {\n    async onDigest(algorithm, data) {\n        return ShakeCrypto.digest(algorithm, data);\n    }\n}\n\nclass SubtleCrypto extends core.SubtleCrypto {\n    constructor() {\n        var _a;\n        super();\n        this.providers.set(new AesCbcProvider());\n        this.providers.set(new AesCtrProvider());\n        this.providers.set(new AesGcmProvider());\n        this.providers.set(new AesCmacProvider());\n        this.providers.set(new AesKwProvider());\n        this.providers.set(new AesEcbProvider());\n        const ciphers = crypto.getCiphers();\n        if (ciphers.includes(\"des-cbc\")) {\n            this.providers.set(new DesCbcProvider());\n        }\n        this.providers.set(new DesEde3CbcProvider());\n        this.providers.set(new RsaSsaProvider());\n        this.providers.set(new RsaPssProvider());\n        this.providers.set(new RsaOaepProvider());\n        this.providers.set(new RsaEsProvider());\n        this.providers.set(new EcdsaProvider());\n        this.providers.set(new EcdhProvider());\n        this.providers.set(new Sha1Provider());\n        this.providers.set(new Sha256Provider());\n        this.providers.set(new Sha384Provider());\n        this.providers.set(new Sha512Provider());\n        this.providers.set(new Pbkdf2Provider());\n        this.providers.set(new HmacProvider());\n        this.providers.set(new HkdfProvider());\n        const nodeMajorVersion = (_a = /^v(\\d+)/.exec(process.version)) === null || _a === void 0 ? void 0 : _a[1];\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 12) {\n            this.providers.set(new Shake128Provider());\n            this.providers.set(new Shake256Provider());\n        }\n        const hashes = crypto.getHashes();\n        if (hashes.includes(\"sha3-256\")) {\n            this.providers.set(new Sha3256Provider());\n        }\n        if (hashes.includes(\"sha3-384\")) {\n            this.providers.set(new Sha3384Provider());\n        }\n        if (hashes.includes(\"sha3-512\")) {\n            this.providers.set(new Sha3512Provider());\n        }\n        if (nodeMajorVersion && parseInt(nodeMajorVersion, 10) >= 14) {\n            this.providers.set(new EdDsaProvider());\n            this.providers.set(new EcdhEsProvider());\n            this.providers.set(new Ed25519Provider());\n            this.providers.set(new X25519Provider());\n        }\n    }\n}\n\nclass Crypto extends core.Crypto {\n    constructor() {\n        super(...arguments);\n        this.subtle = new SubtleCrypto();\n    }\n    getRandomValues(array) {\n        if (!ArrayBuffer.isView(array)) {\n            throw new TypeError(\"Failed to execute 'getRandomValues' on 'Crypto': parameter 1 is not of type 'ArrayBufferView'\");\n        }\n        const buffer = Buffer$1.from(array.buffer, array.byteOffset, array.byteLength);\n        crypto.randomFillSync(buffer);\n        return array;\n    }\n}\n\nexport { Crypto };\n"],"names":[],"mappings":"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","ignoreList":[0]}}]
}